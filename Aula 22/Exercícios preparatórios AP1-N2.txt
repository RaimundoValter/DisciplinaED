## LISTAS HETEROG√äNEAS ##

üß† Exerc√≠cios curtos de implementa√ß√£o

Maior √°rea:
Implemente uma fun√ß√£o lsthet_maior_area(Listahet* l) que percorre a lista e retorna o valor da maior √°rea encontrada entre todas as formas.

Contagem total:
Crie uma fun√ß√£o lsthet_tamanho(Listahet* l) que retorna o n√∫mero total de elementos da lista, independentemente do tipo.

Filtragem por √°rea:
Escreva lsthet_imprime_maiores(Listahet* l, float limite) para imprimir apenas as formas cuja √°rea seja maior que o valor informado.

Percentual por tipo:
Crie uma fun√ß√£o lsthet_percentual_tipo(Listahet* l, Tipo geometria) que retorne o percentual de elementos de determinado tipo em rela√ß√£o ao total da lista.

√Årea m√©dia por tipo:
Desenvolva lsthet_media_area_tipo(Listahet* l, Tipo geometria) para calcular a m√©dia das √°reas de um tipo espec√≠fico (ex: m√©dia de √°reas dos c√≠rculos).

‚öôÔ∏è Exerc√≠cios curtos de uso da TAD (sem modificar a TAD)

Listagem filtrada:
No programa principal, leia uma lista de formas e use lsthet_imprime_tipo
para mostrar apenas os tri√¢ngulos cadastrados.

Compara√ß√£o entre tipos:
Escreva um c√≥digo que compare a √°rea total de ret√¢ngulos com 
a de c√≠rculos e indique qual ocupa mais √°rea na lista.

Remo√ß√£o condicional:
Use lsthet_deleta_formas para remover todos os c√≠rculos caso a √°rea total de c√≠rculos ultrapasse 100.0 unidades.

Busca e exibi√ß√£o:
Utilize lsthet_busca_forma para encontrar o primeiro tri√¢ngulo e imprimir suas dimens√µes isoladamente.

Valida√ß√£o de lista vazia:
Escreva um trecho que verifique se a lista est√° vazia antes de imprimir, evitando acessar ponteiros nulos.

## PILHAS ##

üß† Exerc√≠cios curtos ‚Äì uso da TAD (fun√ß√µes j√° implementadas)

Empilhamento e desempilhamento simples:
No main, crie uma pilha, empilhe tr√™s links (como "https://ifce.edu.br", "https://google.com", "https://github.com"), e depois desempilhe todos imprimindo cada link removido.

Verifica√ß√£o do topo:
Crie uma pilha, empilhe dois links e use pilha_topo para exibir o link atual no topo sem remov√™-lo.

Teste de pilha vazia:
Crie um programa que:

Crie uma pilha;

Teste se est√° vazia (usando pilha_vazia);

Empilhe um link;

Teste novamente e imprima o resultado antes e depois.

Navega√ß√£o simulada:
Implemente um menu simples:

Op√ß√£o 1: visitar novo link;
Op√ß√£o 2: voltar;
Op√ß√£o 3: avan√ßar;
Op√ß√£o 0: sair.
(Simula o hist√≥rico de navega√ß√£o de um navegador.)

Libera√ß√£o de mem√≥ria:
Crie uma pilha, empilhe alguns links e chame pilha_libera.
Use ferramentas como valgrind (em Linux) para confirmar que n√£o h√° vazamentos de mem√≥ria.

‚öôÔ∏è Exerc√≠cios curtos ‚Äì novas funcionalidades para a TAD

Contagem de elementos:
Implemente int pilha_tamanho(Pilha* p) que retorna o n√∫mero de elementos armazenados.

Impress√£o da pilha:
Crie void pilha_imprime(Pilha* p) que mostre todos os links da pilha, do topo at√© a base, sem alterar a estrutura.

Busca na pilha:
Implemente int pilha_contem(Pilha* p, const char* link) que retorna 1 se o link estiver presente na pilha, e 0 caso contr√°rio.

Remo√ß√£o de todos os elementos iguais:
Desenvolva void pilha_remove_todos(Pilha* p, const char* link) que remove todas as ocorr√™ncias de um mesmo link (exige uso de pilha auxiliar).

Clonagem de pilha:
Crie Pilha* pilha_clone(Pilha* p) que retorna uma nova pilha com c√≥pias dos mesmos links, preservando a ordem original.

Invers√£o da pilha:
Desenvolva void pilha_inverte(Pilha* p) que reorganiza os elementos de forma que o topo vire base e vice-versa (use pilha auxiliar).

Concatena√ß√£o de pilhas:
Escreva void pilha_concatena(Pilha* p1, Pilha* p2) que move todos os elementos de p2 para o topo de p1, esvaziando p2.

## FILAS ##

üß† Exerc√≠cios curtos ‚Äì uso da TAD existente

Cria√ß√£o e inser√ß√£o:
No main, crie uma fila e insira manualmente tr√™s clientes com diferentes prioridades.
Em seguida, use fila_imprime para mostrar a fila completa.

Atendimento de cliente:
Crie uma fila com cinco clientes. Use fila_dequeue para remover o cliente de maior prioridade e imprima o nome atendido.

Fila vazia:
Escreva um programa que:

Crie uma fila vazia;

Verifique com fila_vazia;

Insira um cliente;

Verifique novamente e imprima o resultado antes e depois.

Atendimento cont√≠nuo:
Crie uma fila, insira v√°rios clientes e repita:

Remover o cliente com maior prioridade;

Imprimir o nome atendido;

Mostrar a fila atualizada at√© que fique vazia.

Limpeza de mem√≥ria:
Monte uma fila de testes e libere toda a mem√≥ria com fila_free.
Utilize valgrind (ou similar) para confirmar aus√™ncia de vazamentos.

‚öôÔ∏è Exerc√≠cios curtos ‚Äì novas funcionalidades para a TAD

Contagem de elementos:
Implemente int fila_tamanho(Fila* f) que retorna o n√∫mero de elementos na fila.

Busca por nome:
Crie Lista* fila_busca(Fila* f, const char* nome) que retorna o ponteiro para o n√≥ do cliente, ou NULL caso n√£o exista.

Remo√ß√£o por nome:
Implemente void fila_remove(Fila* f, const char* nome) que remove um 
cliente espec√≠fico da fila, caso exista.

M√©dia de prioridade:
Crie float fila_media_prioridade(Fila* f) que calcula e retorna a m√©dia
 das prioridades dos clientes na fila.

Maior prioridade atual:
Escreva int fila_maior_prioridade(Fila* f) que percorre a fila e retorna a prioridade mais alta presente (sem alterar a estrutura).

Impress√£o filtrada:
Desenvolva void fila_imprime_prioridade(Fila* f, int min_prio) que imprime apenas os clientes com prioridade maior ou igual ao valor informado.

Clonagem de fila:
Crie Fila* fila_clone(Fila* f) que retorna uma nova fila contendo c√≥pias dos mesmos elementos, na mesma ordem.

Fila invertida:
Implemente void fila_inverte(Fila* f) que reorganiza a fila invertendo a ordem dos elementos.

Mesclagem de filas:
Desenvolva Fila* fila_merge(Fila* f1, Fila* f2) que une duas filas em uma √∫nica, respeitando a ordem original de cada uma.